// Copyright (c) 2020 ReactiveUI Association Inc. All rights reserved.
// ReactiveUI Association Inc licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using ReactiveMarbles.ObservableEvents.SourceGenerator.EventGenerators;
using ReactiveMarbles.ObservableEvents.SourceGenerator.EventGenerators.Generators;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace ReactiveMarbles.ObservableEvents.SourceGenerator
{
    /// <summary>
    /// Generates Observables from events in specified types and namespaces.
    /// </summary>
    [Generator]
    public class EventGeneratorHook : ISourceGenerator
    {
        private const string ExtensionMethodText = @"
// <auto-generated />
using System;
namespace ReactiveMarbles.ObservableEvents
{
    internal static partial class ObservableGeneratorExtensions
    {
        [System.Obsolete(""There are no events on your type and therefore Events() is not available."", false)]
        public static NullEvents Events<T>(this T eventHost)
        {
            return default(NullEvents);
        }
    }

    internal struct NullEvents
    {
    }
}";

        private static InstanceEventGenerator _eventGenerator = new InstanceEventGenerator();
        private static StaticEventGenerator _staticEventGenerator = new StaticEventGenerator();

        /// <inheritdoc />
        public void Execute(GeneratorExecutionContext context)
        {
            // add the attribute text.
            context.AddSource("TestExtensions.SourceGenerated.cs", SourceText.From(ExtensionMethodText, Encoding.UTF8));

            var compilation = context.Compilation;
            var options = (compilation as CSharpCompilation)?.SyntaxTrees[0].Options as CSharpParseOptions;
            compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(ExtensionMethodText, Encoding.UTF8), options));

            var methodInvocationExtensions = new List<MethodDeclarationSyntax>();

            GetAvailableTypes(compilation, out var instanceNamespaceList, out var staticNamespaceList);

            GenerateEvents(context, _staticEventGenerator, true, staticNamespaceList);
            GenerateEvents(context, _eventGenerator, false, instanceNamespaceList, methodInvocationExtensions);

            GenerateEventExtensionMethods(context, methodInvocationExtensions);
        }

        /// <inheritdoc />
        public void Initialize(GeneratorInitializationContext context)
        {
        }

        private static void GenerateEventExtensionMethods(GeneratorExecutionContext context, List<MethodDeclarationSyntax> methodInvocationExtensions)
        {
            var classDeclaration = ClassDeclaration("ObservableGeneratorExtensions")
                .WithModifiers(TokenList(Token(SyntaxKind.InternalKeyword), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.PartialKeyword)))
                .WithMembers(List<MemberDeclarationSyntax>(methodInvocationExtensions));

            var namespaceDeclaration = NamespaceDeclaration(IdentifierName("ReactiveMarbles.ObservableEvents"))
                .WithMembers(SingletonList<MemberDeclarationSyntax>(classDeclaration))
                .WithLeadingTrivia(XmlSyntaxFactory.GenerateDocumentationString("<auto-generated />"));

            var compilationUnit = CompilationUnit().WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceDeclaration));

            context.AddSource("TestExtensions.FoundEvents.SourceGenerated.cs", SourceText.From(compilationUnit.NormalizeWhitespace().ToFullString(), Encoding.UTF8));
        }

        private static void GetAvailableTypes(Compilation compilation, out List<INamedTypeSymbol> instanceNamespaceList, out List<INamedTypeSymbol> staticNamespaceList)
        {
            var candidates = new List<INamedTypeSymbol>();

            GetEventMethodCallTypes(compilation, candidates);

            instanceNamespaceList = new List<INamedTypeSymbol>(candidates.Count);
            staticNamespaceList = new List<INamedTypeSymbol>(candidates.Count);
            foreach (var candidate in candidates)
            {
                var list = candidate.IsStatic ? staticNamespaceList : instanceNamespaceList;

                list.Add(candidate);
            }
        }

        private static void GetEventMethodCallTypes(Compilation compilation, List<INamedTypeSymbol> candidates)
        {
            var observableGeneratorExtensions = compilation.GetTypeByMetadataName("ReactiveMarbles.ObservableEvents.ObservableGeneratorExtensions")!;

            foreach (var tree in compilation.SyntaxTrees)
            {
                var semanticModel = compilation.GetSemanticModel(tree);

                foreach (var invocation in tree.GetRoot().DescendantNodesAndSelf().OfType<InvocationExpressionSyntax>())
                {
                    var methodSymbol = semanticModel.GetSymbolInfo(invocation).Symbol as IMethodSymbol;

                    if (methodSymbol == null)
                    {
                        continue;
                    }

                    if (!SymbolEqualityComparer.Default.Equals(methodSymbol.ContainingType, observableGeneratorExtensions))
                    {
                        continue;
                    }

                    if (methodSymbol.TypeArguments.Length != 1)
                    {
                        continue;
                    }

                    var callingSymbol = methodSymbol.TypeArguments[0] as INamedTypeSymbol;

                    if (callingSymbol == null)
                    {
                        continue;
                    }

                    candidates.Add(callingSymbol);
                }
            }
        }

        private static bool GenerateEvents(GeneratorExecutionContext context, IEventSymbolGenerator symbolGenerator, bool isStatic, IReadOnlyList<INamedTypeSymbol> symbols, List<MethodDeclarationSyntax>? methodInvocationExtensions = null)
        {
            var processingStack = new Stack<INamedTypeSymbol>(symbols);
            var processedItems = new HashSet<INamedTypeSymbol>(TypeDefinitionNameComparer.Default);

            var fileType = isStatic ? "Static" : "Instance";

            while (processingStack.Count != 0)
            {
                var item = processingStack.Pop();

                if (processedItems.Contains(item))
                {
                    continue;
                }

                processedItems.Add(item);

                var baseClassWithEvents = item.GetBasesWithCondition(RoslynHelpers.HasEvents).ToList();

                var alwaysGenerate = symbols.Contains(item) && (baseClassWithEvents.Count != 0 || item.GetMembers<IEventSymbol>().Any());

                var namespaceItem = symbolGenerator.Generate(item, alwaysGenerate);

                foreach (var childItem in baseClassWithEvents)
                {
                    processingStack.Push(childItem);
                }

                if (namespaceItem == null)
                {
                    continue;
                }

                var compilationUnit = CompilationUnit().WithMembers(SingletonList<MemberDeclarationSyntax>(namespaceItem))
                    .WithLeadingTrivia(
                        XmlSyntaxFactory.GenerateDocumentationString(
                            "<auto-generated />"));

                var sourceText = compilationUnit.NormalizeWhitespace().ToFullString();

                var name = $"SourceClass{item.ToDisplayString(RoslynHelpers.SymbolDisplayFormat)}-{fileType}Events.SourceGenerated.cs";

                context.AddSource(
                    name,
                    SourceText.From(sourceText, Encoding.UTF8));

                methodInvocationExtensions?.Add(MethodGenerator.GenerateMethod(item));
            }

            return true;
        }
    }
}
